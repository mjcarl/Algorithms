选择排序：首先找到数组中最小的元素，将它和数组的第一个元素交换。再次，在剩下的元素中找出最小的元素，将它与数组的第二个元素交换。如此反复，直到将整个数组排序。  不断地选择剩余元素之中的最小者。
static void sort(int a[])
{
    int N=a.length;
    for(int i=0;i<N;i++)
    {
        int min=i;
        for(int j=i+1;j<N;j++)
        {
            if(a[j]<a[min])
                min=j;
            exch(a,i,min);  //值交换
        }
    }
}

插入排序：将一张牌插入到其他已经排序的牌中的适当位置。从左到右依次移动，把新的tmp往前查找插入合适的位置。适用于数组中每个元素距离它的正确位置不远，或只有少数元素位置不正确等。
static void InsertionSort(int a[],int N)
{
    int j,p;
    int tmp;
    for(p=1;p<N;p++)
    {
        tmp=a[p];
        for(j=p;j>0&&a[j-1]>tmp;j--)
            a[j]=a[j-1];
        a[j]=tmp;
    }
}

归并排序：基本思想是先递归的将它分成两半分别排序，再将结果归并起来（划分子区间+合并子区间）。它能保证所用时间和NlogN成正比，不足是它所需的额外空间和N成正比。

程序见VS2017


思考总结：排序后关联性的问题   a1 a2-->a1 a2
